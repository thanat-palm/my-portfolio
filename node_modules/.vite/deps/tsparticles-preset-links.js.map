{
  "version": 3,
  "sources": ["../../tsparticles-move-base/esm/Utils.js", "../../tsparticles-move-base/esm/BaseMover.js", "../../tsparticles-move-base/esm/index.js", "../../tsparticles-shape-circle/esm/CircleDrawer.js", "../../tsparticles-shape-circle/esm/index.js", "../../tsparticles-updater-color/esm/Utils.js", "../../tsparticles-updater-color/esm/ColorUpdater.js", "../../tsparticles-updater-color/esm/index.js", "../../tsparticles-updater-opacity/esm/Utils.js", "../../tsparticles-updater-opacity/esm/OpacityUpdater.js", "../../tsparticles-updater-opacity/esm/index.js", "../../tsparticles-updater-out-modes/esm/Utils.js", "../../tsparticles-updater-out-modes/esm/BounceOutMode.js", "../../tsparticles-updater-out-modes/esm/DestroyOutMode.js", "../../tsparticles-updater-out-modes/esm/NoneOutMode.js", "../../tsparticles-updater-out-modes/esm/OutOutMode.js", "../../tsparticles-updater-out-modes/esm/OutOfCanvasUpdater.js", "../../tsparticles-updater-out-modes/esm/index.js", "../../tsparticles-updater-size/esm/Utils.js", "../../tsparticles-updater-size/esm/SizeUpdater.js", "../../tsparticles-updater-size/esm/index.js", "../../tsparticles-basic/esm/index.js", "../../tsparticles-interaction-particles-links/esm/CircleWarp.js", "../../tsparticles-interaction-particles-links/esm/Options/Classes/LinksShadow.js", "../../tsparticles-interaction-particles-links/esm/Options/Classes/LinksTriangle.js", "../../tsparticles-interaction-particles-links/esm/Options/Classes/Links.js", "../../tsparticles-interaction-particles-links/esm/Linker.js", "../../tsparticles-interaction-particles-links/esm/interaction.js", "../../tsparticles-interaction-particles-links/esm/Utils.js", "../../tsparticles-interaction-particles-links/esm/LinkInstance.js", "../../tsparticles-interaction-particles-links/esm/plugin.js", "../../tsparticles-interaction-particles-links/esm/index.js", "../../tsparticles-preset-links/esm/options.js", "../../tsparticles-preset-links/esm/index.js"],
  "sourcesContent": ["import { clamp, getDistances, getRandom, } from \"tsparticles-engine\";\nexport function applyDistance(particle) {\n    const initialPosition = particle.initialPosition, { dx, dy } = getDistances(initialPosition, particle.position), dxFixed = Math.abs(dx), dyFixed = Math.abs(dy), { maxDistance } = particle.retina, hDistance = maxDistance.horizontal, vDistance = maxDistance.vertical;\n    if (!hDistance && !vDistance) {\n        return;\n    }\n    if (((hDistance && dxFixed >= hDistance) || (vDistance && dyFixed >= vDistance)) && !particle.misplaced) {\n        particle.misplaced = (!!hDistance && dxFixed > hDistance) || (!!vDistance && dyFixed > vDistance);\n        if (hDistance) {\n            particle.velocity.x = particle.velocity.y / 2 - particle.velocity.x;\n        }\n        if (vDistance) {\n            particle.velocity.y = particle.velocity.x / 2 - particle.velocity.y;\n        }\n    }\n    else if ((!hDistance || dxFixed < hDistance) && (!vDistance || dyFixed < vDistance) && particle.misplaced) {\n        particle.misplaced = false;\n    }\n    else if (particle.misplaced) {\n        const pos = particle.position, vel = particle.velocity;\n        if (hDistance && ((pos.x < initialPosition.x && vel.x < 0) || (pos.x > initialPosition.x && vel.x > 0))) {\n            vel.x *= -getRandom();\n        }\n        if (vDistance && ((pos.y < initialPosition.y && vel.y < 0) || (pos.y > initialPosition.y && vel.y > 0))) {\n            vel.y *= -getRandom();\n        }\n    }\n}\nexport function move(particle, moveOptions, moveSpeed, maxSpeed, moveDrift, delta) {\n    applyPath(particle, delta);\n    const gravityOptions = particle.gravity, gravityFactor = gravityOptions?.enable && gravityOptions.inverse ? -1 : 1;\n    if (moveDrift && moveSpeed) {\n        particle.velocity.x += (moveDrift * delta.factor) / (60 * moveSpeed);\n    }\n    if (gravityOptions?.enable && moveSpeed) {\n        particle.velocity.y += (gravityFactor * (gravityOptions.acceleration * delta.factor)) / (60 * moveSpeed);\n    }\n    const decay = particle.moveDecay;\n    particle.velocity.multTo(decay);\n    const velocity = particle.velocity.mult(moveSpeed);\n    if (gravityOptions?.enable &&\n        maxSpeed > 0 &&\n        ((!gravityOptions.inverse && velocity.y >= 0 && velocity.y >= maxSpeed) ||\n            (gravityOptions.inverse && velocity.y <= 0 && velocity.y <= -maxSpeed))) {\n        velocity.y = gravityFactor * maxSpeed;\n        if (moveSpeed) {\n            particle.velocity.y = velocity.y / moveSpeed;\n        }\n    }\n    const zIndexOptions = particle.options.zIndex, zVelocityFactor = (1 - particle.zIndexFactor) ** zIndexOptions.velocityRate;\n    velocity.multTo(zVelocityFactor);\n    const { position } = particle;\n    position.addTo(velocity);\n    if (moveOptions.vibrate) {\n        position.x += Math.sin(position.x * Math.cos(position.y));\n        position.y += Math.cos(position.y * Math.sin(position.x));\n    }\n}\nexport function spin(particle, moveSpeed) {\n    const container = particle.container;\n    if (!particle.spin) {\n        return;\n    }\n    const updateFunc = {\n        x: particle.spin.direction === \"clockwise\" ? Math.cos : Math.sin,\n        y: particle.spin.direction === \"clockwise\" ? Math.sin : Math.cos,\n    };\n    particle.position.x = particle.spin.center.x + particle.spin.radius * updateFunc.x(particle.spin.angle);\n    particle.position.y = particle.spin.center.y + particle.spin.radius * updateFunc.y(particle.spin.angle);\n    particle.spin.radius += particle.spin.acceleration;\n    const maxCanvasSize = Math.max(container.canvas.size.width, container.canvas.size.height);\n    if (particle.spin.radius > maxCanvasSize / 2) {\n        particle.spin.radius = maxCanvasSize / 2;\n        particle.spin.acceleration *= -1;\n    }\n    else if (particle.spin.radius < 0) {\n        particle.spin.radius = 0;\n        particle.spin.acceleration *= -1;\n    }\n    particle.spin.angle += (moveSpeed / 100) * (1 - particle.spin.radius / maxCanvasSize);\n}\nexport function applyPath(particle, delta) {\n    const particlesOptions = particle.options, pathOptions = particlesOptions.move.path, pathEnabled = pathOptions.enable;\n    if (!pathEnabled) {\n        return;\n    }\n    if (particle.lastPathTime <= particle.pathDelay) {\n        particle.lastPathTime += delta.value;\n        return;\n    }\n    const path = particle.pathGenerator?.generate(particle, delta);\n    if (path) {\n        particle.velocity.addTo(path);\n    }\n    if (pathOptions.clamp) {\n        particle.velocity.x = clamp(particle.velocity.x, -1, 1);\n        particle.velocity.y = clamp(particle.velocity.y, -1, 1);\n    }\n    particle.lastPathTime -= particle.pathDelay;\n}\nexport function getProximitySpeedFactor(particle) {\n    return particle.slow.inRange ? particle.slow.factor : 1;\n}\n", "import { getDistance, getRangeMax, getRangeValue, } from \"tsparticles-engine\";\nimport { applyDistance, getProximitySpeedFactor, move, spin } from \"./Utils\";\nconst diffFactor = 2;\nexport class BaseMover {\n    constructor() {\n        this._initSpin = (particle) => {\n            const container = particle.container, options = particle.options, spinOptions = options.move.spin;\n            if (!spinOptions.enable) {\n                return;\n            }\n            const spinPos = spinOptions.position ?? { x: 50, y: 50 }, spinCenter = {\n                x: (spinPos.x / 100) * container.canvas.size.width,\n                y: (spinPos.y / 100) * container.canvas.size.height,\n            }, pos = particle.getPosition(), distance = getDistance(pos, spinCenter), spinAcceleration = getRangeValue(spinOptions.acceleration);\n            particle.retina.spinAcceleration = spinAcceleration * container.retina.pixelRatio;\n            particle.spin = {\n                center: spinCenter,\n                direction: particle.velocity.x >= 0 ? \"clockwise\" : \"counter-clockwise\",\n                angle: particle.velocity.angle,\n                radius: distance,\n                acceleration: particle.retina.spinAcceleration,\n            };\n        };\n    }\n    init(particle) {\n        const options = particle.options, gravityOptions = options.move.gravity;\n        particle.gravity = {\n            enable: gravityOptions.enable,\n            acceleration: getRangeValue(gravityOptions.acceleration),\n            inverse: gravityOptions.inverse,\n        };\n        this._initSpin(particle);\n    }\n    isEnabled(particle) {\n        return !particle.destroyed && particle.options.move.enable;\n    }\n    move(particle, delta) {\n        const particleOptions = particle.options, moveOptions = particleOptions.move;\n        if (!moveOptions.enable) {\n            return;\n        }\n        const container = particle.container, pxRatio = container.retina.pixelRatio, slowFactor = getProximitySpeedFactor(particle), baseSpeed = (particle.retina.moveSpeed ??= getRangeValue(moveOptions.speed) * pxRatio) *\n            container.retina.reduceFactor, moveDrift = (particle.retina.moveDrift ??= getRangeValue(particle.options.move.drift) * pxRatio), maxSize = getRangeMax(particleOptions.size.value) * pxRatio, sizeFactor = moveOptions.size ? particle.getRadius() / maxSize : 1, moveSpeed = (baseSpeed * sizeFactor * slowFactor * (delta.factor || 1)) / diffFactor, maxSpeed = particle.retina.maxSpeed ?? container.retina.maxSpeed;\n        if (moveOptions.spin.enable) {\n            spin(particle, moveSpeed);\n        }\n        else {\n            move(particle, moveOptions, moveSpeed, maxSpeed, moveDrift, delta);\n        }\n        applyDistance(particle);\n    }\n}\n", "import { BaseMover } from \"./BaseMover\";\nexport async function loadBaseMover(engine, refresh = true) {\n    await engine.addMover(\"base\", () => new BaseMover(), refresh);\n}\n", "import { isObject } from \"tsparticles-engine\";\nexport class CircleDrawer {\n    draw(context, particle, radius) {\n        if (!particle.circleRange) {\n            particle.circleRange = { min: 0, max: Math.PI * 2 };\n        }\n        const circleRange = particle.circleRange;\n        context.arc(0, 0, radius, circleRange.min, circleRange.max, false);\n    }\n    getSidesCount() {\n        return 12;\n    }\n    particleInit(container, particle) {\n        const shapeData = particle.shapeData, angle = shapeData?.angle ?? {\n            max: 360,\n            min: 0,\n        };\n        particle.circleRange = !isObject(angle)\n            ? {\n                min: 0,\n                max: (angle * Math.PI) / 180,\n            }\n            : { min: (angle.min * Math.PI) / 180, max: (angle.max * Math.PI) / 180 };\n    }\n}\n", "import { CircleDrawer } from \"./CircleDrawer\";\nexport async function loadCircleShape(engine, refresh = true) {\n    await engine.addShape(\"circle\", new CircleDrawer(), refresh);\n}\n", "import { randomInRange, } from \"tsparticles-engine\";\nfunction updateColorValue(delta, colorValue, valueAnimation, max, decrease) {\n    if (!colorValue ||\n        !valueAnimation.enable ||\n        ((colorValue.maxLoops ?? 0) > 0 && (colorValue.loops ?? 0) > (colorValue.maxLoops ?? 0))) {\n        return;\n    }\n    if (!colorValue.time) {\n        colorValue.time = 0;\n    }\n    if ((colorValue.delayTime ?? 0) > 0 && colorValue.time < (colorValue.delayTime ?? 0)) {\n        colorValue.time += delta.value;\n    }\n    if ((colorValue.delayTime ?? 0) > 0 && colorValue.time < (colorValue.delayTime ?? 0)) {\n        return;\n    }\n    const offset = randomInRange(valueAnimation.offset), velocity = (colorValue.velocity ?? 0) * delta.factor + offset * 3.6, decay = colorValue.decay ?? 1;\n    if (!decrease || colorValue.status === \"increasing\") {\n        colorValue.value += velocity;\n        if (colorValue.value > max) {\n            if (!colorValue.loops) {\n                colorValue.loops = 0;\n            }\n            colorValue.loops++;\n            if (decrease) {\n                colorValue.status = \"decreasing\";\n                colorValue.value -= colorValue.value % max;\n            }\n        }\n    }\n    else {\n        colorValue.value -= velocity;\n        if (colorValue.value < 0) {\n            if (!colorValue.loops) {\n                colorValue.loops = 0;\n            }\n            colorValue.loops++;\n            colorValue.status = \"increasing\";\n            colorValue.value += colorValue.value;\n        }\n    }\n    if (colorValue.velocity && decay !== 1) {\n        colorValue.velocity *= decay;\n    }\n    if (colorValue.value > max) {\n        colorValue.value %= max;\n    }\n}\nexport function updateColor(particle, delta) {\n    const { h: hAnimation, s: sAnimation, l: lAnimation } = particle.options.color.animation, { color } = particle;\n    if (!color) {\n        return;\n    }\n    const { h, s, l } = color;\n    if (h) {\n        updateColorValue(delta, h, hAnimation, 360, false);\n    }\n    if (s) {\n        updateColorValue(delta, s, sAnimation, 100, true);\n    }\n    if (l) {\n        updateColorValue(delta, l, lAnimation, 100, true);\n    }\n}\n", "import { getHslAnimationFromHsl, rangeColorToHsl, } from \"tsparticles-engine\";\nimport { updateColor } from \"./Utils\";\nexport class ColorUpdater {\n    constructor(container) {\n        this.container = container;\n    }\n    init(particle) {\n        const hslColor = rangeColorToHsl(particle.options.color, particle.id, particle.options.reduceDuplicates);\n        if (hslColor) {\n            particle.color = getHslAnimationFromHsl(hslColor, particle.options.color.animation, this.container.retina.reduceFactor);\n        }\n    }\n    isEnabled(particle) {\n        const { h: hAnimation, s: sAnimation, l: lAnimation } = particle.options.color.animation, { color } = particle;\n        return (!particle.destroyed &&\n            !particle.spawning &&\n            ((color?.h.value !== undefined && hAnimation.enable) ||\n                (color?.s.value !== undefined && sAnimation.enable) ||\n                (color?.l.value !== undefined && lAnimation.enable)));\n    }\n    update(particle, delta) {\n        updateColor(particle, delta);\n    }\n}\n", "import { ColorUpdater } from \"./ColorUpdater\";\nexport async function loadColorUpdater(engine, refresh = true) {\n    await engine.addParticleUpdater(\"color\", (container) => new ColorUpdater(container), refresh);\n}\n", "import { clamp } from \"tsparticles-engine\";\nfunction checkDestroy(particle, value, minValue, maxValue) {\n    switch (particle.options.opacity.animation.destroy) {\n        case \"max\":\n            if (value >= maxValue) {\n                particle.destroy();\n            }\n            break;\n        case \"min\":\n            if (value <= minValue) {\n                particle.destroy();\n            }\n            break;\n    }\n}\nexport function updateOpacity(particle, delta) {\n    const data = particle.opacity;\n    if (particle.destroyed || !data?.enable || ((data.maxLoops ?? 0) > 0 && (data.loops ?? 0) > (data.maxLoops ?? 0))) {\n        return;\n    }\n    const minValue = data.min, maxValue = data.max, decay = data.decay ?? 1;\n    if (!data.time) {\n        data.time = 0;\n    }\n    if ((data.delayTime ?? 0) > 0 && data.time < (data.delayTime ?? 0)) {\n        data.time += delta.value;\n    }\n    if ((data.delayTime ?? 0) > 0 && data.time < (data.delayTime ?? 0)) {\n        return;\n    }\n    switch (data.status) {\n        case \"increasing\":\n            if (data.value >= maxValue) {\n                data.status = \"decreasing\";\n                if (!data.loops) {\n                    data.loops = 0;\n                }\n                data.loops++;\n            }\n            else {\n                data.value += (data.velocity ?? 0) * delta.factor;\n            }\n            break;\n        case \"decreasing\":\n            if (data.value <= minValue) {\n                data.status = \"increasing\";\n                if (!data.loops) {\n                    data.loops = 0;\n                }\n                data.loops++;\n            }\n            else {\n                data.value -= (data.velocity ?? 0) * delta.factor;\n            }\n            break;\n    }\n    if (data.velocity && data.decay !== 1) {\n        data.velocity *= decay;\n    }\n    checkDestroy(particle, data.value, minValue, maxValue);\n    if (!particle.destroyed) {\n        data.value = clamp(data.value, minValue, maxValue);\n    }\n}\n", "import { getRandom, getRangeValue, initParticleNumericAnimationValue, } from \"tsparticles-engine\";\nimport { updateOpacity } from \"./Utils\";\nexport class OpacityUpdater {\n    constructor(container) {\n        this.container = container;\n    }\n    init(particle) {\n        const opacityOptions = particle.options.opacity;\n        particle.opacity = initParticleNumericAnimationValue(opacityOptions, 1);\n        const opacityAnimation = opacityOptions.animation;\n        if (opacityAnimation.enable) {\n            particle.opacity.velocity =\n                (getRangeValue(opacityAnimation.speed) / 100) * this.container.retina.reduceFactor;\n            if (!opacityAnimation.sync) {\n                particle.opacity.velocity *= getRandom();\n            }\n        }\n    }\n    isEnabled(particle) {\n        return (!particle.destroyed &&\n            !particle.spawning &&\n            !!particle.opacity &&\n            particle.opacity.enable &&\n            ((particle.opacity.maxLoops ?? 0) <= 0 ||\n                ((particle.opacity.maxLoops ?? 0) > 0 &&\n                    (particle.opacity.loops ?? 0) < (particle.opacity.maxLoops ?? 0))));\n    }\n    reset(particle) {\n        if (particle.opacity) {\n            particle.opacity.time = 0;\n            particle.opacity.loops = 0;\n        }\n    }\n    update(particle, delta) {\n        if (!this.isEnabled(particle)) {\n            return;\n        }\n        updateOpacity(particle, delta);\n    }\n}\n", "import { OpacityUpdater } from \"./OpacityUpdater\";\nexport async function loadOpacityUpdater(engine, refresh = true) {\n    await engine.addParticleUpdater(\"opacity\", (container) => new OpacityUpdater(container), refresh);\n}\n", "import { getValue } from \"tsparticles-engine\";\nexport function bounceHorizontal(data) {\n    if ((data.outMode !== \"bounce\" &&\n        data.outMode !== \"bounce-horizontal\" &&\n        data.outMode !== \"bounceHorizontal\" &&\n        data.outMode !== \"split\") ||\n        (data.direction !== \"left\" && data.direction !== \"right\")) {\n        return;\n    }\n    if (data.bounds.right < 0 && data.direction === \"left\") {\n        data.particle.position.x = data.size + data.offset.x;\n    }\n    else if (data.bounds.left > data.canvasSize.width && data.direction === \"right\") {\n        data.particle.position.x = data.canvasSize.width - data.size - data.offset.x;\n    }\n    const velocity = data.particle.velocity.x;\n    let bounced = false;\n    if ((data.direction === \"right\" && data.bounds.right >= data.canvasSize.width && velocity > 0) ||\n        (data.direction === \"left\" && data.bounds.left <= 0 && velocity < 0)) {\n        const newVelocity = getValue(data.particle.options.bounce.horizontal);\n        data.particle.velocity.x *= -newVelocity;\n        bounced = true;\n    }\n    if (!bounced) {\n        return;\n    }\n    const minPos = data.offset.x + data.size;\n    if (data.bounds.right >= data.canvasSize.width && data.direction === \"right\") {\n        data.particle.position.x = data.canvasSize.width - minPos;\n    }\n    else if (data.bounds.left <= 0 && data.direction === \"left\") {\n        data.particle.position.x = minPos;\n    }\n    if (data.outMode === \"split\") {\n        data.particle.destroy();\n    }\n}\nexport function bounceVertical(data) {\n    if ((data.outMode !== \"bounce\" &&\n        data.outMode !== \"bounce-vertical\" &&\n        data.outMode !== \"bounceVertical\" &&\n        data.outMode !== \"split\") ||\n        (data.direction !== \"bottom\" && data.direction !== \"top\")) {\n        return;\n    }\n    if (data.bounds.bottom < 0 && data.direction === \"top\") {\n        data.particle.position.y = data.size + data.offset.y;\n    }\n    else if (data.bounds.top > data.canvasSize.height && data.direction === \"bottom\") {\n        data.particle.position.y = data.canvasSize.height - data.size - data.offset.y;\n    }\n    const velocity = data.particle.velocity.y;\n    let bounced = false;\n    if ((data.direction === \"bottom\" && data.bounds.bottom >= data.canvasSize.height && velocity > 0) ||\n        (data.direction === \"top\" && data.bounds.top <= 0 && velocity < 0)) {\n        const newVelocity = getValue(data.particle.options.bounce.vertical);\n        data.particle.velocity.y *= -newVelocity;\n        bounced = true;\n    }\n    if (!bounced) {\n        return;\n    }\n    const minPos = data.offset.y + data.size;\n    if (data.bounds.bottom >= data.canvasSize.height && data.direction === \"bottom\") {\n        data.particle.position.y = data.canvasSize.height - minPos;\n    }\n    else if (data.bounds.top <= 0 && data.direction === \"top\") {\n        data.particle.position.y = minPos;\n    }\n    if (data.outMode === \"split\") {\n        data.particle.destroy();\n    }\n}\n", "import { calculateBounds, } from \"tsparticles-engine\";\nimport { bounceHorizontal, bounceVertical } from \"./Utils\";\nexport class BounceOutMode {\n    constructor(container) {\n        this.container = container;\n        this.modes = [\n            \"bounce\",\n            \"bounce-vertical\",\n            \"bounce-horizontal\",\n            \"bounceVertical\",\n            \"bounceHorizontal\",\n            \"split\",\n        ];\n    }\n    update(particle, direction, delta, outMode) {\n        if (!this.modes.includes(outMode)) {\n            return;\n        }\n        const container = this.container;\n        let handled = false;\n        for (const [, plugin] of container.plugins) {\n            if (plugin.particleBounce !== undefined) {\n                handled = plugin.particleBounce(particle, delta, direction);\n            }\n            if (handled) {\n                break;\n            }\n        }\n        if (handled) {\n            return;\n        }\n        const pos = particle.getPosition(), offset = particle.offset, size = particle.getRadius(), bounds = calculateBounds(pos, size), canvasSize = container.canvas.size;\n        bounceHorizontal({ particle, outMode, direction, bounds, canvasSize, offset, size });\n        bounceVertical({ particle, outMode, direction, bounds, canvasSize, offset, size });\n    }\n}\n", "import { Vector, getDistances, isPointInside, } from \"tsparticles-engine\";\nexport class DestroyOutMode {\n    constructor(container) {\n        this.container = container;\n        this.modes = [\"destroy\"];\n    }\n    update(particle, direction, _delta, outMode) {\n        if (!this.modes.includes(outMode)) {\n            return;\n        }\n        const container = this.container;\n        switch (particle.outType) {\n            case \"normal\":\n            case \"outside\":\n                if (isPointInside(particle.position, container.canvas.size, Vector.origin, particle.getRadius(), direction)) {\n                    return;\n                }\n                break;\n            case \"inside\": {\n                const { dx, dy } = getDistances(particle.position, particle.moveCenter);\n                const { x: vx, y: vy } = particle.velocity;\n                if ((vx < 0 && dx > particle.moveCenter.radius) ||\n                    (vy < 0 && dy > particle.moveCenter.radius) ||\n                    (vx >= 0 && dx < -particle.moveCenter.radius) ||\n                    (vy >= 0 && dy < -particle.moveCenter.radius)) {\n                    return;\n                }\n                break;\n            }\n        }\n        container.particles.remove(particle, undefined, true);\n    }\n}\n", "import { Vector, isPointInside, } from \"tsparticles-engine\";\nexport class NoneOutMode {\n    constructor(container) {\n        this.container = container;\n        this.modes = [\"none\"];\n    }\n    update(particle, direction, delta, outMode) {\n        if (!this.modes.includes(outMode)) {\n            return;\n        }\n        if ((particle.options.move.distance.horizontal &&\n            (direction === \"left\" || direction === \"right\")) ||\n            (particle.options.move.distance.vertical &&\n                (direction === \"top\" || direction === \"bottom\"))) {\n            return;\n        }\n        const gravityOptions = particle.options.move.gravity, container = this.container;\n        const canvasSize = container.canvas.size;\n        const pRadius = particle.getRadius();\n        if (!gravityOptions.enable) {\n            if ((particle.velocity.y > 0 && particle.position.y <= canvasSize.height + pRadius) ||\n                (particle.velocity.y < 0 && particle.position.y >= -pRadius) ||\n                (particle.velocity.x > 0 && particle.position.x <= canvasSize.width + pRadius) ||\n                (particle.velocity.x < 0 && particle.position.x >= -pRadius)) {\n                return;\n            }\n            if (!isPointInside(particle.position, container.canvas.size, Vector.origin, pRadius, direction)) {\n                container.particles.remove(particle);\n            }\n        }\n        else {\n            const position = particle.position;\n            if ((!gravityOptions.inverse &&\n                position.y > canvasSize.height + pRadius &&\n                direction === \"bottom\") ||\n                (gravityOptions.inverse && position.y < -pRadius && direction === \"top\")) {\n                container.particles.remove(particle);\n            }\n        }\n    }\n}\n", "import { Vector, calculateBounds, getDistances, getRandom, isPointInside, randomInRange, } from \"tsparticles-engine\";\nexport class OutOutMode {\n    constructor(container) {\n        this.container = container;\n        this.modes = [\"out\"];\n    }\n    update(particle, direction, delta, outMode) {\n        if (!this.modes.includes(outMode)) {\n            return;\n        }\n        const container = this.container;\n        switch (particle.outType) {\n            case \"inside\": {\n                const { x: vx, y: vy } = particle.velocity;\n                const circVec = Vector.origin;\n                circVec.length = particle.moveCenter.radius;\n                circVec.angle = particle.velocity.angle + Math.PI;\n                circVec.addTo(Vector.create(particle.moveCenter));\n                const { dx, dy } = getDistances(particle.position, circVec);\n                if ((vx <= 0 && dx >= 0) || (vy <= 0 && dy >= 0) || (vx >= 0 && dx <= 0) || (vy >= 0 && dy <= 0)) {\n                    return;\n                }\n                particle.position.x = Math.floor(randomInRange({\n                    min: 0,\n                    max: container.canvas.size.width,\n                }));\n                particle.position.y = Math.floor(randomInRange({\n                    min: 0,\n                    max: container.canvas.size.height,\n                }));\n                const { dx: newDx, dy: newDy } = getDistances(particle.position, particle.moveCenter);\n                particle.direction = Math.atan2(-newDy, -newDx);\n                particle.velocity.angle = particle.direction;\n                break;\n            }\n            default: {\n                if (isPointInside(particle.position, container.canvas.size, Vector.origin, particle.getRadius(), direction)) {\n                    return;\n                }\n                switch (particle.outType) {\n                    case \"outside\": {\n                        particle.position.x =\n                            Math.floor(randomInRange({\n                                min: -particle.moveCenter.radius,\n                                max: particle.moveCenter.radius,\n                            })) + particle.moveCenter.x;\n                        particle.position.y =\n                            Math.floor(randomInRange({\n                                min: -particle.moveCenter.radius,\n                                max: particle.moveCenter.radius,\n                            })) + particle.moveCenter.y;\n                        const { dx, dy } = getDistances(particle.position, particle.moveCenter);\n                        if (particle.moveCenter.radius) {\n                            particle.direction = Math.atan2(dy, dx);\n                            particle.velocity.angle = particle.direction;\n                        }\n                        break;\n                    }\n                    case \"normal\": {\n                        const wrap = particle.options.move.warp, canvasSize = container.canvas.size, newPos = {\n                            bottom: canvasSize.height + particle.getRadius() + particle.offset.y,\n                            left: -particle.getRadius() - particle.offset.x,\n                            right: canvasSize.width + particle.getRadius() + particle.offset.x,\n                            top: -particle.getRadius() - particle.offset.y,\n                        }, sizeValue = particle.getRadius(), nextBounds = calculateBounds(particle.position, sizeValue);\n                        if (direction === \"right\" &&\n                            nextBounds.left > canvasSize.width + particle.offset.x) {\n                            particle.position.x = newPos.left;\n                            particle.initialPosition.x = particle.position.x;\n                            if (!wrap) {\n                                particle.position.y = getRandom() * canvasSize.height;\n                                particle.initialPosition.y = particle.position.y;\n                            }\n                        }\n                        else if (direction === \"left\" && nextBounds.right < -particle.offset.x) {\n                            particle.position.x = newPos.right;\n                            particle.initialPosition.x = particle.position.x;\n                            if (!wrap) {\n                                particle.position.y = getRandom() * canvasSize.height;\n                                particle.initialPosition.y = particle.position.y;\n                            }\n                        }\n                        if (direction === \"bottom\" &&\n                            nextBounds.top > canvasSize.height + particle.offset.y) {\n                            if (!wrap) {\n                                particle.position.x = getRandom() * canvasSize.width;\n                                particle.initialPosition.x = particle.position.x;\n                            }\n                            particle.position.y = newPos.top;\n                            particle.initialPosition.y = particle.position.y;\n                        }\n                        else if (direction === \"top\" && nextBounds.bottom < -particle.offset.y) {\n                            if (!wrap) {\n                                particle.position.x = getRandom() * canvasSize.width;\n                                particle.initialPosition.x = particle.position.x;\n                            }\n                            particle.position.y = newPos.bottom;\n                            particle.initialPosition.y = particle.position.y;\n                        }\n                        break;\n                    }\n                }\n                break;\n            }\n        }\n    }\n}\n", "import { BounceOutMode } from \"./BounceOutMode\";\nimport { DestroyOutMode } from \"./DestroyOutMode\";\nimport { NoneOutMode } from \"./NoneOutMode\";\nimport { OutOutMode } from \"./OutOutMode\";\nexport class OutOfCanvasUpdater {\n    constructor(container) {\n        this.container = container;\n        this._updateOutMode = (particle, delta, outMode, direction) => {\n            for (const updater of this.updaters) {\n                updater.update(particle, direction, delta, outMode);\n            }\n        };\n        this.updaters = [\n            new BounceOutMode(container),\n            new DestroyOutMode(container),\n            new OutOutMode(container),\n            new NoneOutMode(container),\n        ];\n    }\n    init() {\n    }\n    isEnabled(particle) {\n        return !particle.destroyed && !particle.spawning;\n    }\n    update(particle, delta) {\n        const outModes = particle.options.move.outModes;\n        this._updateOutMode(particle, delta, outModes.bottom ?? outModes.default, \"bottom\");\n        this._updateOutMode(particle, delta, outModes.left ?? outModes.default, \"left\");\n        this._updateOutMode(particle, delta, outModes.right ?? outModes.default, \"right\");\n        this._updateOutMode(particle, delta, outModes.top ?? outModes.default, \"top\");\n    }\n}\n", "import { OutOfCanvasUpdater } from \"./OutOfCanvasUpdater\";\nexport async function loadOutModesUpdater(engine, refresh = true) {\n    await engine.addParticleUpdater(\"outModes\", (container) => new OutOfCanvasUpdater(container), refresh);\n}\n", "import { clamp } from \"tsparticles-engine\";\nfunction checkDestroy(particle, value, minValue, maxValue) {\n    switch (particle.options.size.animation.destroy) {\n        case \"max\":\n            if (value >= maxValue) {\n                particle.destroy();\n            }\n            break;\n        case \"min\":\n            if (value <= minValue) {\n                particle.destroy();\n            }\n            break;\n    }\n}\nexport function updateSize(particle, delta) {\n    const data = particle.size;\n    if (particle.destroyed ||\n        !data ||\n        !data.enable ||\n        ((data.maxLoops ?? 0) > 0 && (data.loops ?? 0) > (data.maxLoops ?? 0))) {\n        return;\n    }\n    const sizeVelocity = (data.velocity ?? 0) * delta.factor, minValue = data.min, maxValue = data.max, decay = data.decay ?? 1;\n    if (!data.time) {\n        data.time = 0;\n    }\n    if ((data.delayTime ?? 0) > 0 && data.time < (data.delayTime ?? 0)) {\n        data.time += delta.value;\n    }\n    if ((data.delayTime ?? 0) > 0 && data.time < (data.delayTime ?? 0)) {\n        return;\n    }\n    switch (data.status) {\n        case \"increasing\":\n            if (data.value >= maxValue) {\n                data.status = \"decreasing\";\n                if (!data.loops) {\n                    data.loops = 0;\n                }\n                data.loops++;\n            }\n            else {\n                data.value += sizeVelocity;\n            }\n            break;\n        case \"decreasing\":\n            if (data.value <= minValue) {\n                data.status = \"increasing\";\n                if (!data.loops) {\n                    data.loops = 0;\n                }\n                data.loops++;\n            }\n            else {\n                data.value -= sizeVelocity;\n            }\n    }\n    if (data.velocity && decay !== 1) {\n        data.velocity *= decay;\n    }\n    checkDestroy(particle, data.value, minValue, maxValue);\n    if (!particle.destroyed) {\n        data.value = clamp(data.value, minValue, maxValue);\n    }\n}\n", "import { getRandom } from \"tsparticles-engine\";\nimport { updateSize } from \"./Utils\";\nexport class SizeUpdater {\n    init(particle) {\n        const container = particle.container, sizeOptions = particle.options.size, sizeAnimation = sizeOptions.animation;\n        if (sizeAnimation.enable) {\n            particle.size.velocity =\n                ((particle.retina.sizeAnimationSpeed ?? container.retina.sizeAnimationSpeed) / 100) *\n                    container.retina.reduceFactor;\n            if (!sizeAnimation.sync) {\n                particle.size.velocity *= getRandom();\n            }\n        }\n    }\n    isEnabled(particle) {\n        return (!particle.destroyed &&\n            !particle.spawning &&\n            particle.size.enable &&\n            ((particle.size.maxLoops ?? 0) <= 0 ||\n                ((particle.size.maxLoops ?? 0) > 0 && (particle.size.loops ?? 0) < (particle.size.maxLoops ?? 0))));\n    }\n    reset(particle) {\n        particle.size.loops = 0;\n    }\n    update(particle, delta) {\n        if (!this.isEnabled(particle)) {\n            return;\n        }\n        updateSize(particle, delta);\n    }\n}\n", "import { SizeUpdater } from \"./SizeUpdater\";\nexport async function loadSizeUpdater(engine, refresh = true) {\n    await engine.addParticleUpdater(\"size\", () => new SizeUpdater(), refresh);\n}\n", "import { loadBaseMover } from \"tsparticles-move-base\";\nimport { loadCircleShape } from \"tsparticles-shape-circle\";\nimport { loadColorUpdater } from \"tsparticles-updater-color\";\nimport { loadOpacityUpdater } from \"tsparticles-updater-opacity\";\nimport { loadOutModesUpdater } from \"tsparticles-updater-out-modes\";\nimport { loadSizeUpdater } from \"tsparticles-updater-size\";\nexport async function loadBasic(engine, refresh = true) {\n    await loadBaseMover(engine, false);\n    await loadCircleShape(engine, false);\n    await loadColorUpdater(engine, false);\n    await loadOpacityUpdater(engine, false);\n    await loadOutModesUpdater(engine, false);\n    await loadSizeUpdater(engine, false);\n    await engine.refresh(refresh);\n}\n", "import { Circle, Rectangle } from \"tsparticles-engine\";\nexport class CircleWarp extends Circle {\n    constructor(x, y, radius, canvasSize) {\n        super(x, y, radius);\n        this.canvasSize = canvasSize;\n        this.canvasSize = { ...canvasSize };\n    }\n    contains(point) {\n        const { width, height } = this.canvasSize;\n        const { x, y } = point;\n        return (super.contains(point) ||\n            super.contains({ x: x - width, y }) ||\n            super.contains({ x: x - width, y: y - height }) ||\n            super.contains({ x, y: y - height }));\n    }\n    intersects(range) {\n        if (super.intersects(range)) {\n            return true;\n        }\n        const rect = range, circle = range, newPos = {\n            x: range.position.x - this.canvasSize.width,\n            y: range.position.y - this.canvasSize.height,\n        };\n        if (circle.radius !== undefined) {\n            const biggerCircle = new Circle(newPos.x, newPos.y, circle.radius * 2);\n            return super.intersects(biggerCircle);\n        }\n        else if (rect.size !== undefined) {\n            const rectSW = new Rectangle(newPos.x, newPos.y, rect.size.width * 2, rect.size.height * 2);\n            return super.intersects(rectSW);\n        }\n        return false;\n    }\n}\n", "import { OptionsColor } from \"tsparticles-engine\";\nexport class LinksShadow {\n    constructor() {\n        this.blur = 5;\n        this.color = new OptionsColor();\n        this.color.value = \"#000\";\n        this.enable = false;\n    }\n    load(data) {\n        if (!data) {\n            return;\n        }\n        if (data.blur !== undefined) {\n            this.blur = data.blur;\n        }\n        this.color = OptionsColor.create(this.color, data.color);\n        if (data.enable !== undefined) {\n            this.enable = data.enable;\n        }\n    }\n}\n", "import { OptionsColor } from \"tsparticles-engine\";\nexport class LinksTriangle {\n    constructor() {\n        this.enable = false;\n        this.frequency = 1;\n    }\n    load(data) {\n        if (!data) {\n            return;\n        }\n        if (data.color !== undefined) {\n            this.color = OptionsColor.create(this.color, data.color);\n        }\n        if (data.enable !== undefined) {\n            this.enable = data.enable;\n        }\n        if (data.frequency !== undefined) {\n            this.frequency = data.frequency;\n        }\n        if (data.opacity !== undefined) {\n            this.opacity = data.opacity;\n        }\n    }\n}\n", "import { OptionsColor } from \"tsparticles-engine\";\nimport { LinksShadow } from \"./LinksShadow\";\nimport { LinksTriangle } from \"./LinksTriangle\";\nexport class Links {\n    constructor() {\n        this.blink = false;\n        this.color = new OptionsColor();\n        this.color.value = \"#fff\";\n        this.consent = false;\n        this.distance = 100;\n        this.enable = false;\n        this.frequency = 1;\n        this.opacity = 1;\n        this.shadow = new LinksShadow();\n        this.triangles = new LinksTriangle();\n        this.width = 1;\n        this.warp = false;\n    }\n    load(data) {\n        if (!data) {\n            return;\n        }\n        if (data.id !== undefined) {\n            this.id = data.id;\n        }\n        if (data.blink !== undefined) {\n            this.blink = data.blink;\n        }\n        this.color = OptionsColor.create(this.color, data.color);\n        if (data.consent !== undefined) {\n            this.consent = data.consent;\n        }\n        if (data.distance !== undefined) {\n            this.distance = data.distance;\n        }\n        if (data.enable !== undefined) {\n            this.enable = data.enable;\n        }\n        if (data.frequency !== undefined) {\n            this.frequency = data.frequency;\n        }\n        if (data.opacity !== undefined) {\n            this.opacity = data.opacity;\n        }\n        this.shadow.load(data.shadow);\n        this.triangles.load(data.triangles);\n        if (data.width !== undefined) {\n            this.width = data.width;\n        }\n        if (data.warp !== undefined) {\n            this.warp = data.warp;\n        }\n    }\n}\n", "import { Circle, ParticlesInteractorBase, getDistances, getLinkRandomColor, } from \"tsparticles-engine\";\nimport { CircleWarp } from \"./CircleWarp\";\nimport { Links } from \"./Options/Classes/Links\";\nfunction getLinkDistance(pos1, pos2, optDistance, canvasSize, warp) {\n    const { dx, dy, distance } = getDistances(pos1, pos2);\n    if (!warp || distance <= optDistance) {\n        return distance;\n    }\n    const absDiffs = {\n        x: Math.abs(dx),\n        y: Math.abs(dy),\n    }, warpDistances = {\n        x: Math.min(absDiffs.x, canvasSize.width - absDiffs.x),\n        y: Math.min(absDiffs.y, canvasSize.height - absDiffs.y),\n    };\n    return Math.sqrt(warpDistances.x ** 2 + warpDistances.y ** 2);\n}\nexport class Linker extends ParticlesInteractorBase {\n    constructor(container) {\n        super(container);\n        this._setColor = (p1) => {\n            if (!p1.options.links) {\n                return;\n            }\n            const container = this.linkContainer, linksOptions = p1.options.links;\n            let linkColor = linksOptions.id === undefined\n                ? container.particles.linksColor\n                : container.particles.linksColors.get(linksOptions.id);\n            if (linkColor) {\n                return;\n            }\n            const optColor = linksOptions.color;\n            linkColor = getLinkRandomColor(optColor, linksOptions.blink, linksOptions.consent);\n            if (linksOptions.id === undefined) {\n                container.particles.linksColor = linkColor;\n            }\n            else {\n                container.particles.linksColors.set(linksOptions.id, linkColor);\n            }\n        };\n        this.linkContainer = container;\n    }\n    clear() {\n    }\n    init() {\n        this.linkContainer.particles.linksColor = undefined;\n        this.linkContainer.particles.linksColors = new Map();\n    }\n    async interact(p1) {\n        if (!p1.options.links) {\n            return;\n        }\n        p1.links = [];\n        const pos1 = p1.getPosition(), container = this.container, canvasSize = container.canvas.size;\n        if (pos1.x < 0 || pos1.y < 0 || pos1.x > canvasSize.width || pos1.y > canvasSize.height) {\n            return;\n        }\n        const linkOpt1 = p1.options.links, optOpacity = linkOpt1.opacity, optDistance = p1.retina.linksDistance ?? 0, warp = linkOpt1.warp, range = warp\n            ? new CircleWarp(pos1.x, pos1.y, optDistance, canvasSize)\n            : new Circle(pos1.x, pos1.y, optDistance), query = container.particles.quadTree.query(range);\n        for (const p2 of query) {\n            const linkOpt2 = p2.options.links;\n            if (p1 === p2 ||\n                !linkOpt2?.enable ||\n                linkOpt1.id !== linkOpt2.id ||\n                p2.spawning ||\n                p2.destroyed ||\n                !p2.links ||\n                p1.links.some((t) => t.destination === p2) ||\n                p2.links.some((t) => t.destination === p1)) {\n                continue;\n            }\n            const pos2 = p2.getPosition();\n            if (pos2.x < 0 || pos2.y < 0 || pos2.x > canvasSize.width || pos2.y > canvasSize.height) {\n                continue;\n            }\n            const distance = getLinkDistance(pos1, pos2, optDistance, canvasSize, warp && linkOpt2.warp);\n            if (distance > optDistance) {\n                continue;\n            }\n            const opacityLine = (1 - distance / optDistance) * optOpacity;\n            this._setColor(p1);\n            p1.links.push({\n                destination: p2,\n                opacity: opacityLine,\n            });\n        }\n    }\n    isEnabled(particle) {\n        return !!particle.options.links?.enable;\n    }\n    loadParticlesOptions(options, ...sources) {\n        if (!options.links) {\n            options.links = new Links();\n        }\n        for (const source of sources) {\n            options.links.load(source?.links ?? source?.lineLinked ?? source?.line_linked);\n        }\n    }\n    reset() {\n    }\n}\n", "import { Linker } from \"./Linker\";\nexport async function loadLinksInteraction(engine, refresh = true) {\n    await engine.addInteractor(\"particlesLinks\", (container) => new Linker(container), refresh);\n}\n", "import { drawLine, drawTriangle, getDistance, getDistances, getRandom, getStyleFromRgb, rangeColorToRgb, } from \"tsparticles-engine\";\nexport function drawLinkLine(params) {\n    let drawn = false;\n    const { begin, end, maxDistance, context, canvasSize, width, backgroundMask, colorLine, opacity, links } = params;\n    if (getDistance(begin, end) <= maxDistance) {\n        drawLine(context, begin, end);\n        drawn = true;\n    }\n    else if (links.warp) {\n        let pi1;\n        let pi2;\n        const endNE = {\n            x: end.x - canvasSize.width,\n            y: end.y,\n        };\n        const d1 = getDistances(begin, endNE);\n        if (d1.distance <= maxDistance) {\n            const yi = begin.y - (d1.dy / d1.dx) * begin.x;\n            pi1 = { x: 0, y: yi };\n            pi2 = { x: canvasSize.width, y: yi };\n        }\n        else {\n            const endSW = {\n                x: end.x,\n                y: end.y - canvasSize.height,\n            };\n            const d2 = getDistances(begin, endSW);\n            if (d2.distance <= maxDistance) {\n                const yi = begin.y - (d2.dy / d2.dx) * begin.x;\n                const xi = -yi / (d2.dy / d2.dx);\n                pi1 = { x: xi, y: 0 };\n                pi2 = { x: xi, y: canvasSize.height };\n            }\n            else {\n                const endSE = {\n                    x: end.x - canvasSize.width,\n                    y: end.y - canvasSize.height,\n                };\n                const d3 = getDistances(begin, endSE);\n                if (d3.distance <= maxDistance) {\n                    const yi = begin.y - (d3.dy / d3.dx) * begin.x;\n                    const xi = -yi / (d3.dy / d3.dx);\n                    pi1 = { x: xi, y: yi };\n                    pi2 = { x: pi1.x + canvasSize.width, y: pi1.y + canvasSize.height };\n                }\n            }\n        }\n        if (pi1 && pi2) {\n            drawLine(context, begin, pi1);\n            drawLine(context, end, pi2);\n            drawn = true;\n        }\n    }\n    if (!drawn) {\n        return;\n    }\n    context.lineWidth = width;\n    if (backgroundMask.enable) {\n        context.globalCompositeOperation = backgroundMask.composite;\n    }\n    context.strokeStyle = getStyleFromRgb(colorLine, opacity);\n    const { shadow } = links;\n    if (shadow.enable) {\n        const shadowColor = rangeColorToRgb(shadow.color);\n        if (shadowColor) {\n            context.shadowBlur = shadow.blur;\n            context.shadowColor = getStyleFromRgb(shadowColor);\n        }\n    }\n    context.stroke();\n}\nexport function drawLinkTriangle(params) {\n    const { context, pos1, pos2, pos3, backgroundMask, colorTriangle, opacityTriangle } = params;\n    drawTriangle(context, pos1, pos2, pos3);\n    if (backgroundMask.enable) {\n        context.globalCompositeOperation = backgroundMask.composite;\n    }\n    context.fillStyle = getStyleFromRgb(colorTriangle, opacityTriangle);\n    context.fill();\n}\nexport function getLinkKey(ids) {\n    ids.sort((a, b) => a - b);\n    return ids.join(\"_\");\n}\nexport function setLinkFrequency(particles, dictionary) {\n    const key = getLinkKey(particles.map((t) => t.id));\n    let res = dictionary.get(key);\n    if (res === undefined) {\n        res = getRandom();\n        dictionary.set(key, res);\n    }\n    return res;\n}\n", "import { getDistance, getLinkColor, getRandom, getRangeValue, rangeColorToRgb, } from \"tsparticles-engine\";\nimport { drawLinkLine, drawLinkTriangle, setLinkFrequency } from \"./Utils\";\nexport class LinkInstance {\n    constructor(container) {\n        this.container = container;\n        this._drawLinkLine = (p1, link) => {\n            const p1LinksOptions = p1.options.links;\n            if (!p1LinksOptions?.enable) {\n                return;\n            }\n            const container = this.container, options = container.actualOptions, p2 = link.destination, pos1 = p1.getPosition(), pos2 = p2.getPosition();\n            let opacity = link.opacity;\n            container.canvas.draw((ctx) => {\n                let colorLine;\n                const twinkle = p1.options.twinkle?.lines;\n                if (twinkle?.enable) {\n                    const twinkleFreq = twinkle.frequency, twinkleRgb = rangeColorToRgb(twinkle.color), twinkling = getRandom() < twinkleFreq;\n                    if (twinkling && twinkleRgb) {\n                        colorLine = twinkleRgb;\n                        opacity = getRangeValue(twinkle.opacity);\n                    }\n                }\n                if (!colorLine) {\n                    const linkColor = p1LinksOptions.id !== undefined\n                        ? container.particles.linksColors.get(p1LinksOptions.id)\n                        : container.particles.linksColor;\n                    colorLine = getLinkColor(p1, p2, linkColor);\n                }\n                if (!colorLine) {\n                    return;\n                }\n                const width = p1.retina.linksWidth ?? 0, maxDistance = p1.retina.linksDistance ?? 0, { backgroundMask } = options;\n                drawLinkLine({\n                    context: ctx,\n                    width,\n                    begin: pos1,\n                    end: pos2,\n                    maxDistance,\n                    canvasSize: container.canvas.size,\n                    links: p1LinksOptions,\n                    backgroundMask: backgroundMask,\n                    colorLine,\n                    opacity,\n                });\n            });\n        };\n        this._drawLinkTriangle = (p1, link1, link2) => {\n            const linksOptions = p1.options.links;\n            if (!linksOptions?.enable) {\n                return;\n            }\n            const triangleOptions = linksOptions.triangles;\n            if (!triangleOptions.enable) {\n                return;\n            }\n            const container = this.container, options = container.actualOptions, p2 = link1.destination, p3 = link2.destination, opacityTriangle = triangleOptions.opacity ?? (link1.opacity + link2.opacity) / 2;\n            if (opacityTriangle <= 0) {\n                return;\n            }\n            container.canvas.draw((ctx) => {\n                const pos1 = p1.getPosition(), pos2 = p2.getPosition(), pos3 = p3.getPosition(), linksDistance = p1.retina.linksDistance ?? 0;\n                if (getDistance(pos1, pos2) > linksDistance ||\n                    getDistance(pos3, pos2) > linksDistance ||\n                    getDistance(pos3, pos1) > linksDistance) {\n                    return;\n                }\n                let colorTriangle = rangeColorToRgb(triangleOptions.color);\n                if (!colorTriangle) {\n                    const linkColor = linksOptions.id !== undefined\n                        ? container.particles.linksColors.get(linksOptions.id)\n                        : container.particles.linksColor;\n                    colorTriangle = getLinkColor(p1, p2, linkColor);\n                }\n                if (!colorTriangle) {\n                    return;\n                }\n                drawLinkTriangle({\n                    context: ctx,\n                    pos1,\n                    pos2,\n                    pos3,\n                    backgroundMask: options.backgroundMask,\n                    colorTriangle,\n                    opacityTriangle,\n                });\n            });\n        };\n        this._drawTriangles = (options, p1, link, p1Links) => {\n            const p2 = link.destination;\n            if (!(options.links?.triangles.enable && p2.options.links?.triangles.enable)) {\n                return;\n            }\n            const vertices = p2.links?.filter((t) => {\n                const linkFreq = this._getLinkFrequency(p2, t.destination);\n                return (p2.options.links &&\n                    linkFreq <= p2.options.links.frequency &&\n                    p1Links.findIndex((l) => l.destination === t.destination) >= 0);\n            });\n            if (!vertices?.length) {\n                return;\n            }\n            for (const vertex of vertices) {\n                const p3 = vertex.destination, triangleFreq = this._getTriangleFrequency(p1, p2, p3);\n                if (triangleFreq > options.links.triangles.frequency) {\n                    continue;\n                }\n                this._drawLinkTriangle(p1, link, vertex);\n            }\n        };\n        this._getLinkFrequency = (p1, p2) => {\n            return setLinkFrequency([p1, p2], this._freqs.links);\n        };\n        this._getTriangleFrequency = (p1, p2, p3) => {\n            return setLinkFrequency([p1, p2, p3], this._freqs.triangles);\n        };\n        this._freqs = {\n            links: new Map(),\n            triangles: new Map(),\n        };\n    }\n    drawParticle(context, particle) {\n        const { links, options } = particle;\n        if (!links || links.length <= 0) {\n            return;\n        }\n        const p1Links = links.filter((l) => options.links && this._getLinkFrequency(particle, l.destination) <= options.links.frequency);\n        for (const link of p1Links) {\n            this._drawTriangles(options, particle, link, p1Links);\n            if (link.opacity > 0 && (particle.retina.linksWidth ?? 0) > 0) {\n                this._drawLinkLine(particle, link);\n            }\n        }\n    }\n    async init() {\n        this._freqs.links = new Map();\n        this._freqs.triangles = new Map();\n    }\n    particleCreated(particle) {\n        particle.links = [];\n        if (!particle.options.links) {\n            return;\n        }\n        const ratio = this.container.retina.pixelRatio, { retina } = particle, { distance, width } = particle.options.links;\n        retina.linksDistance = distance * ratio;\n        retina.linksWidth = width * ratio;\n    }\n    particleDestroyed(particle) {\n        particle.links = [];\n    }\n}\n", "import { LinkInstance } from \"./LinkInstance\";\nclass LinksPlugin {\n    constructor() {\n        this.id = \"links\";\n    }\n    getPlugin(container) {\n        return new LinkInstance(container);\n    }\n    loadOptions() {\n    }\n    needsPlugin() {\n        return true;\n    }\n}\nexport async function loadLinksPlugin(engine, refresh = true) {\n    const plugin = new LinksPlugin();\n    await engine.addPlugin(plugin, refresh);\n}\n", "import { loadLinksInteraction } from \"./interaction\";\nimport { loadLinksPlugin } from \"./plugin\";\nexport async function loadParticlesLinksInteraction(engine, refresh = true) {\n    await loadLinksInteraction(engine, refresh);\n    await loadLinksPlugin(engine, refresh);\n}\nexport * from \"./Options/Classes/Links\";\nexport * from \"./Options/Classes/LinksShadow\";\nexport * from \"./Options/Classes/LinksTriangle\";\nexport * from \"./Options/Interfaces/ILinks\";\nexport * from \"./Options/Interfaces/ILinksShadow\";\nexport * from \"./Options/Interfaces/ILinksTriangle\";\n", "export const options = {\n    background: {\n        color: \"#000000\",\n    },\n    particles: {\n        number: {\n            value: 100,\n        },\n        links: {\n            distance: 150,\n            enable: true,\n        },\n        move: {\n            enable: true,\n        },\n        size: {\n            value: 1,\n        },\n        shape: {\n            type: \"circle\",\n        },\n    },\n};\n", "import { loadBasic } from \"tsparticles-basic\";\nimport { loadParticlesLinksInteraction } from \"tsparticles-interaction-particles-links\";\nimport { options } from \"./options\";\nexport async function loadLinksPreset(engine, refresh = true) {\n    await loadBasic(engine, false);\n    await loadParticlesLinksInteraction(engine, false);\n    await engine.addPreset(\"links\", options, refresh);\n}\n"],
  "mappings": "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",
  "names": ["options", "checkDestroy", "container", "options", "container", "options"]
}
